# -*- coding: utf-8 -*-
"""zinevabev1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RZedMm6VayDFCXPgSo2PG9elCdG08t5Q
"""

!pip install ultralytics
!pip install requests

from ultralytics import YOLO
import cv2
import numpy as np
import matplotlib.pyplot as plt
import torch
import requests
import base64
import time
import json
import math
from datetime import datetime
import pytz

def draw_perspective_lines(image, road_mask, standard_road_width_meters=3.5, distance_between_lines_meters=10, max_distance_meters=100):
    """
    วาดเส้นบนถนนทุก ๆ ระยะที่กำหนดในหน่วยเมตร และระบุระยะทางบนเส้นเหล่านั้น

    Parameters:
    - image: รูปภาพต้นฉบับในรูปแบบ RGB
    - road_mask: มาสก์ถนนในรูปแบบ ndarray
    - standard_road_width_meters: ความกว้างถนนในหน่วยเมตร
    - distance_between_lines_meters: ระยะห่างระหว่างเส้นในหน่วยเมตร
    - max_distance_meters: ระยะสูงสุดที่จะวาดเส้นในหน่วยเมตร

    Returns:
    - result_image: รูปภาพที่วาดเส้นและระบุระยะทางแล้ว
    - y_positions: ตำแหน่ง y ของเส้นที่วาด
    """
    try:
        height, width = road_mask.shape[:2]
        road_pixels = np.where(road_mask > 0)
        if len(road_pixels[0]) == 0:
            print("[DEBUG] No road pixels found.")
            return image, []

        # คำนวณตำแหน่งสูงสุดและต่ำสุดของถนนในภาพ
        top_y = np.min(road_pixels[0])
        bottom_y = np.max(road_pixels[0])
        road_height_pixels = bottom_y - top_y

        print(f"[DEBUG] top_y: {top_y}, bottom_y: {bottom_y}, road_height_pixels: {road_height_pixels}")

        if road_height_pixels <= 0:
            print("[DEBUG] Invalid road_height_pixels. Cannot draw lines.")
            return image, []

        # สมมติว่าความยาวที่มองเห็นคือ max_distance_meters
        meters_per_pixel_y = max_distance_meters / road_height_pixels
        print(f"[DEBUG] meters_per_pixel_y: {meters_per_pixel_y}")

        # สร้างรายการระยะทางที่ต้องการวาดเส้น (10, 20, ..., max_distance_meters)
        distances_meters = list(range(distance_between_lines_meters, max_distance_meters + distance_between_lines_meters, distance_between_lines_meters))
        print(f"[DEBUG] distances_meters: {distances_meters}")

        # สร้างตำแหน่ง y สำหรับวาดเส้นตามระยะทาง
        y_positions = []
        for distance in distances_meters:
            y = int(bottom_y - (distance / meters_per_pixel_y))
            if y < top_y:
                print(f"[DEBUG] y={y} is above top_y={top_y}. Stopping.")
                break
            y_positions.append(y)
        print(f"[DEBUG] y_positions: {y_positions}")

        if not y_positions:
            print("[DEBUG] No y_positions calculated. No lines to draw.")
            return image, []

        result_image = image.copy()
        road_mask_3d = np.stack([road_mask] * 3, axis=2)
        result_image = cv2.addWeighted(result_image, 0.7, (road_mask_3d > 0).astype(np.uint8) * image, 0.3, 0)

        # วาดเส้นตาม y_positions และระบุระยะทาง
        for y, distance in zip(y_positions, distances_meters):
            if y < 0 or y >= height:
                print(f"[DEBUG] Skipping out-of-bound y: {y}")
                continue
            row_pixels = np.where(road_mask[y, :] > 0)[0]
            if len(row_pixels) > 0:
                left_x = row_pixels[0]
                right_x = row_pixels[-1]
                # ทำให้ความหนาของเส้นเพิ่มขึ้นตามระยะทาง
                thickness = int(2 + (distance / max_distance_meters) * 3)
                cv2.line(result_image, (left_x, y), (right_x, y), (255, 255, 255), thickness)
                print(f"[DEBUG] Drawn line at y={y} (distance={distance}m) from x={left_x} to x={right_x} with thickness={thickness}")

                # ระบุระยะทางบนเส้น
                text = f"{distance}m"
                font = cv2.FONT_HERSHEY_SIMPLEX
                font_scale = 0.6
                text_thickness = 2
                text_size, _ = cv2.getTextSize(text, font, font_scale, text_thickness)
                text_x = right_x - text_size[0] - 10  # ตำแหน่ง x ของข้อความ (10 พิกเซลจากขวาของเส้น)
                text_y = y - 10  # ตำแหน่ง y ของข้อความ (10 พิกเซลจากเส้น)

                # ตรวจสอบว่าข้อความไม่ออกนอกภาพ
                if text_y < 0:
                    text_y = y + text_size[1] + 10

                cv2.putText(result_image, text, (text_x, text_y), font, font_scale, (255, 255, 255), text_thickness, cv2.LINE_AA)
                print(f"[DEBUG] Added text '{text}' at ({text_x}, {text_y})")
            else:
                print(f"[DEBUG] No road pixels found at y={y}")

        return result_image, y_positions
    except Exception as e:
        print(f"[ERROR in draw_perspective_lines]: {e}")
        return image, []

def process_road_image(image_path, model_path, params):
    """
    ประมวลผลการตรวจจับถนนจากรูปภาพ

    Parameters:
    - image_path: เส้นทางของรูปภาพ
    - model_path: เส้นทางของโมเดลถนน
    - params: พารามิเตอร์ต่าง ๆ

    Returns:
    - road_found: Boolean ว่าพบถนนหรือไม่
    - road_mask: มาสก์ถนน
    - result_image: รูปภาพที่วาดเส้นแล้ว
    - y_positions: ตำแหน่ง y ของเส้นที่วาด
    """
    try:
        print("[DEBUG] Loading road model...")
        road_model = YOLO(model_path)
        print("[DEBUG] Road model loaded. Running inference...")
        road_results = road_model(image_path, conf=params['confidence_threshold'])
        print("[DEBUG] Inference done.")

        if isinstance(road_results, list) and len(road_results) > 0:
            road_result = road_results[0]
            class_names = road_model.names

            road_class_id = None
            for cls_id, cls_name in class_names.items():
                if cls_name.lower() == 'road':
                    road_class_id = cls_id
                    break
            print(f"[DEBUG] road_class_id: {road_class_id}")

            image = cv2.imread(image_path)
            if image is None:
                print(f"[ERROR] Image not found or could not be loaded: {image_path}")
                return False, None, None, []

            image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
            road_mask = np.zeros((road_result.orig_shape[0], road_result.orig_shape[1]), dtype=np.uint8)

            if road_class_id is not None and road_result.masks is not None:
                for mask, cls in zip(road_result.masks.data, road_result.boxes.cls):
                    if int(cls) == road_class_id:
                        mask_image = mask.cpu().numpy().astype(np.uint8) * 255
                        if mask_image.shape != road_mask.shape:
                            mask_image = cv2.resize(
                                mask_image,
                                (road_mask.shape[1], road_mask.shape[0]),
                                interpolation=cv2.INTER_NEAREST
                            )
                        road_mask = cv2.bitwise_or(road_mask, mask_image)

            print(f"[DEBUG] road_mask sum: {np.sum(road_mask)}")
            if np.sum(road_mask) == 0:
                print("[DEBUG] road_mask is empty. No road detected.")

            if np.sum(road_mask) > 0:
                print("[DEBUG] Road mask found. Drawing perspective lines...")
                result_image, y_positions = draw_perspective_lines(
                    image,
                    road_mask,
                    params['standard_road_width_meters'],
                    distance_between_lines_meters=params['distance_between_lines_meters'],
                    max_distance_meters=params.get('max_distance_meters', 100)  # default 100 meters
                )
                return True, road_mask, result_image, y_positions
            else:
                print("[DEBUG] No 'road' segment found in the image.")
                return False, None, image, []
        else:
            print("[DEBUG] No results from the road model.")
            return False, None, None, []
    except Exception as e:
        print(f"[ERROR in process_road_image]: {e}")
        return False, None, None, []

def encode_image(image_path):
    """
    เข้ารหัสรูปภาพเป็น Base64

    Parameters:
    - image_path: เส้นทางของรูปภาพ

    Returns:
    - ข้อความ Base64 ของรูปภาพ
    """
    try:
        with open(image_path, "rb") as img_file:
            data = base64.b64encode(img_file.read()).decode('utf-8')
            print(f"[DEBUG] Image encoded. Length: {len(data)} chars.")
            return data
    except FileNotFoundError:
        print(f"[ERROR] Image file not found: {image_path}")
        return None
    except Exception as e:
        print(f"[ERROR in encode_image]: {e}")
        return None

def send_to_server(url, data):
    """
    ส่งข้อมูลไปยังเซิร์ฟเวอร์

    Parameters:
    - url: URL ของเซิร์ฟเวอร์
    - data: ข้อมูลที่ต้องการส่ง

    Returns:
    - คำตอบจากเซิร์ฟเวอร์
    """
    headers = {'Content-Type': 'application/json'}
    print("[DEBUG] Sending data to server...")
    try:
        response = requests.post(url, json=data, headers=headers)
        print("[DEBUG] Response received.")
        return response
    except requests.exceptions.RequestException as e:
        print(f"[ERROR sending data to server]: {e}")
        return None

def calculate_destination_latlong(lat, lon, distance_m, bearing_degrees):
    """
    คำนวณตำแหน่งละติจูดและลองจิจูดใหม่จากระยะทางและทิศทาง

    Parameters:
    - lat: ละติจูดปัจจุบัน
    - lon: ลองจิจูดปัจจุบัน
    - distance_m: ระยะทางในหน่วยเมตร
    - bearing_degrees: ทิศทางในองศา

    Returns:
    - ละติจูดและลองจิจูดใหม่
    """
    try:
        R = 6378137.0  # รัศมีของโลกในหน่วยเมตร
        bearing = math.radians(bearing_degrees)
        lat_rad = math.radians(lat)
        lon_rad = math.radians(lon)

        lat_new = math.asin(math.sin(lat_rad)*math.cos(distance_m/R) +
                            math.cos(lat_rad)*math.sin(distance_m/R)*math.cos(bearing))

        lon_new = lon_rad + math.atan2(math.sin(bearing)*math.sin(distance_m/R)*math.cos(lat_rad),
                                       math.cos(distance_m/R)-math.sin(lat_rad)*math.sin(lat_new))

        lat_new_deg = math.degrees(lat_new)
        lon_new_deg = math.degrees(lon_new)
        return lat_new_deg, lon_new_deg
    except Exception as e:
        print(f"[ERROR in calculate_destination_latlong]: {e}")
        return None, None

def detect_objects(image_path, model, class_names, conf_threshold=0.5):
    """
    ตรวจจับวัตถุ (ช้างและรถยนต์) จากรูปภาพโดยใช้โมเดล YOLO

    Parameters:
    - image_path: เส้นทางของรูปภาพ
    - model: โมเดล YOLO ที่โหลดไว้แล้ว
    - class_names: ชื่อคลาสจากโมเดล
    - conf_threshold: ค่า threshold สำหรับความมั่นใจ

    Returns:
    - detected: Boolean ว่ามีวัตถุถูกตรวจจับหรือไม่
    - boxes: ตำแหน่งของวัตถุที่ตรวจจับ
    - class_ids: รหัสคลาสของวัตถุที่ตรวจจับ
    """
    try:
        results = model(image_path, conf=conf_threshold)
        detected = False
        boxes = []
        class_ids = []

        for result in results:
            if result.boxes is not None:
                for box, cls in zip(result.boxes.xyxy, result.boxes.cls):
                    cls = int(cls)
                    class_name = class_names.get(cls, None)
                    if class_name is not None and class_name.lower() in ['elephant', 'car']:
                        detected = True
                        boxes.append(box.cpu().numpy())
                        class_ids.append(cls)
                        print(f"[DEBUG] Detected {class_name} with box {box.cpu().numpy()}")

        print(f"[DEBUG] detect_objects: {detected}, boxes={len(boxes)}")
        return detected, boxes, class_ids
    except Exception as e:
        print(f"[ERROR in detect_objects]: {e}")
        return False, [], []

def create_test_payload(camera_id, camera_lat, camera_long, objects_detected, camera_bearing_degrees, elephant_distance_m, image_path):
    """
    สร้าง payload สำหรับส่งไปยังเซิร์ฟเวอร์

    Parameters:
    - camera_id: รหัสของกล้อง
    - camera_lat: ละติจูดของกล้อง
    - camera_long: ลองจิจูดของกล้อง
    - objects_detected: รายการวัตถุที่ตรวจจับ
    - camera_bearing_degrees: ทิศทางของกล้อง
    - elephant_distance_m: ระยะห่างของช้างในหน่วยเมตร
    - image_path: เส้นทางของรูปภาพ

    Returns:
    - payload: ข้อมูลในรูปแบบ dictionary
    """
    try:
        elephant_lat = None
        elephant_long = None
        alert = False
        elephant_detected = False
        car_detected = False

        if objects_detected:
            for obj in objects_detected:
                if obj['class_name'].lower() == 'elephant':
                    elephant_detected = True
                elif obj['class_name'].lower() == 'car':
                    car_detected = True

        if elephant_detected and elephant_distance_m is not None:
            elephant_lat, elephant_long = calculate_destination_latlong(camera_lat, camera_long, elephant_distance_m, camera_bearing_degrees)

        if elephant_detected and car_detected:
            alert = True

        image_data = encode_image(image_path)

        # Get current time in Thailand timezone
        th_tz = pytz.timezone('Asia/Bangkok')
        th_time = datetime.now(th_tz)
        timestamp = th_time.strftime("%Y-%m-%d %H:%M:%S")

        payload = {
            "camera_id": str(camera_id),
            "camera_lat": float(camera_lat),
            "camera_long": float(camera_long),
            "elephant": elephant_detected,
            "elephant_lat": float(elephant_lat) if elephant_detected and elephant_lat is not None else None,
            "elephant_long": float(elephant_long) if elephant_detected and elephant_long is not None else None,
            "elephant_distance": int(elephant_distance_m) if elephant_detected and elephant_distance_m is not None else None,
            "image": image_data,
            "alert": alert,
            "timestamp": timestamp
        }

        print("[DEBUG] Payload created with Thailand timestamp:", timestamp)
        return payload
    except Exception as e:
        print(f"[ERROR in create_test_payload]: {e}")
        return {}

if __name__ == "__main__":
    # Debug Configuration
    CONFIG = {
        'image_path': '/content/p01p1-3.jpg',
        'road_model_path': 'Road.pt',
        'object_model_path': '/content/ELMoCa.pt',  # ELMoCa.pt สำหรับทั้ง Elephant และ car
        'camera_id': 'TEST_CAM_001',
        'camera_lat': 13.736717,
        'camera_long': 100.523186,
        'bearing_degrees': 45.0,
    }

    PARAMS = {
        'confidence_threshold': 0.1,
        'standard_road_width_meters': 3.5,
        'distance_between_lines_meters': 10,  # ระยะห่างระหว่างเส้นเป็น 10 เมตร
        'max_distance_meters': 100,  # ระยะสูงสุดที่จะวาดเส้นเป็น 100 เมตร
        'output_path': '/content/processed_image.jpg'  # เพิ่มการบันทึกรูปภาพที่ประมวลผลแล้ว
    }

    try:
        # Get current Thailand time
        th_tz = pytz.timezone('Asia/Bangkok')
        current_time = datetime.now(th_tz)
        print(f"[DEBUG] Starting main process... (Thailand Time: {current_time.strftime('%Y-%m-%d %H:%M:%S')})")

        # Process road and get line positions
        road_found, road_mask, processed_image, y_positions = process_road_image(CONFIG['image_path'], CONFIG['road_model_path'], PARAMS)

        # ตรวจสอบว่า road_mask ถูกสร้างขึ้นอย่างถูกต้อง
        if road_found:
            plt.figure(figsize=(5,5))
            plt.imshow(road_mask, cmap='gray')
            plt.title('Road Mask')
            plt.show()

        # Load object detection model once
        print("[DEBUG] Loading object detection model...")
        object_model = YOLO(CONFIG['object_model_path'])
        object_class_names = object_model.names
        print("[DEBUG] Object detection model loaded.")

        # Detect objects (Elephant and car) using ELMoCa.pt
        objects_detected, object_boxes, object_class_ids = detect_objects(CONFIG['image_path'], object_model, object_class_names, conf_threshold=PARAMS['confidence_threshold'])

        # Prepare objects data
        detected_objects = []
        if objects_detected:
            for box, cls_id in zip(object_boxes, object_class_ids):
                class_name = object_class_names.get(cls_id, "Unknown")
                detected_objects.append({
                    "class_name": class_name,
                    "box": box.tolist()  # แปลงเป็น list เพื่อหลีกเลี่ยงปัญหาการแปลงเป็น JSON
                })
        else:
            print("[DEBUG] No objects detected.")

        # Create visualization
        plt.figure(figsize=(15, 5))

        # Plot road detection
        plt.subplot(121)
        if processed_image is not None:
            plt.imshow(processed_image)
            plt.title('Road Detection')
        else:
            original_image = cv2.imread(CONFIG['image_path'])
            original_image = cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB)
            plt.imshow(original_image)
            plt.title('Original Image (No Road Detected)')

        # Plot object detections
        plt.subplot(122)
        original_image = cv2.imread(CONFIG['image_path'])
        original_image = cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB)
        detection_image = original_image.copy()

        # Draw detected objects
        for obj in detected_objects:
            box = obj['box']
            class_name = obj['class_name']
            x1, y1, x2, y2 = map(int, box)
            if class_name.lower() == 'elephant':
                color = (255, 0, 0)  # แดงสำหรับช้าง
            elif class_name.lower() == 'car':
                color = (0, 255, 0)  # เขียวสำหรับรถยนต์
            else:
                color = (0, 0, 255)  # แดงสำหรับวัตถุที่ไม่รู้จัก
            cv2.rectangle(detection_image, (x1, y1), (x2, y2), color, 2)
            cv2.putText(detection_image, class_name, (x1, y1-10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, color, 2)

        plt.imshow(detection_image)
        plt.title('Object Detection')

        # Add timestamp to the plot
        plt.suptitle(f'Detection Results - {current_time.strftime("%Y-%m-%d %H:%M:%S")} (Thailand Time)', fontsize=10)

        # Show the plots
        plt.tight_layout()
        plt.show()

        # Save processed image if output_path is specified
        if PARAMS['output_path']:
            cv2.imwrite(PARAMS['output_path'], cv2.cvtColor(processed_image, cv2.COLOR_RGB2BGR))
            print(f"[DEBUG] Processed image saved to {PARAMS['output_path']}")

        # Calculate elephant distance if detected
        elephant_distance_m = None
        if objects_detected:
            for obj in detected_objects:
                if obj['class_name'].lower() == 'elephant' and len(y_positions) > 0:
                    x1, y1, x2, y2 = obj['box']
                    elephant_bottom_y = y2  # ใช้ y2 เป็นตำแหน่งล่างสุดของ bounding box
                    print(f"[DEBUG] Elephant bottom y: {elephant_bottom_y}")

                    y_positions_arr = np.array(y_positions)
                    diff = np.abs(y_positions_arr - elephant_bottom_y)
                    closest_line_idx = np.argmin(diff)
                    elephant_distance_m = PARAMS['distance_between_lines_meters'] * (closest_line_idx + 1)
                    print(f"[DEBUG] Elephant detected at y={elephant_bottom_y}, closest line idx={closest_line_idx}, distance={elephant_distance_m} meters")
                    break  # Only consider the first detected elephant

        SERVER_URL = "https://aprlabtop.com/elephant_api/Testapi.php"
        data = create_test_payload(
            camera_id=CONFIG['camera_id'],
            camera_lat=CONFIG['camera_lat'],
            camera_long=CONFIG['camera_long'],
            objects_detected=detected_objects,
            camera_bearing_degrees=CONFIG['bearing_degrees'],
            elephant_distance_m=elephant_distance_m,
            image_path=CONFIG['image_path']
        )

        # Debug

        # Debug print only first 20 chars of the base64 image
        data_to_print = data.copy()
        if data_to_print.get("image") and data_to_print["image"] is not None:
            data_to_print["image"] = data_to_print["image"][:20] + "..."
        print("Payload:", json.dumps(data_to_print, indent=4))

        response = send_to_server(SERVER_URL, data)
        if response:
            if response.status_code == 200:
                print("Data sent successfully:", response.text)
            else:
                print("Failed to send data. Status code:", response.status_code, "Response:", response.text)
        else:
            print("[DEBUG] No response from server.")
    except Exception as e:
        print(f"[ERROR in __main__]: {e}")